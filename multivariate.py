# -*- coding: utf-8 -*-
"""multivariate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qA4osLFwtKRFvlpfKiRjQL_efUxn_zYF
"""

import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# Load the data
data_file = '/content/yahoo_data.xlsx'
data = pd.read_excel(data_file)

# Load and preprocess data
data['Date'] = pd.to_datetime(data['Date'])
data.set_index('Date', inplace=True)

# Select features and normalize
features = ['Open', 'High', 'Low', 'Close*', 'Adj Close**', 'Volume']
scaler = MinMaxScaler()
data_normalized = scaler.fit_transform(data[features])

# Create sequences for LSTM
def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length, :-1])  # All features except the last one
        y.append(data[i+seq_length, -2])    # Target: Adj Close**
    return np.array(X), np.array(y)

SEQ_LENGTH = 60  # Use the past 60 days to predict the next day
X, y = create_sequences(data_normalized, SEQ_LENGTH)

# Split into training and testing datasets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Build LSTM model
model = Sequential([
    LSTM(50, activation='relu', return_sequences=True, input_shape=(SEQ_LENGTH, X.shape[2])),
    Dropout(0.2),
    LSTM(50, activation='relu'),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')

# Train the model
history = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=50, batch_size=32)

# Evaluate the model
loss = model.evaluate(X_test, y_test)
print(f'Test Loss: {loss}')

# Plot training history
plt.figure(figsize=(10, 6))
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Predict and plot results
y_pred = model.predict(X_test)
plt.figure(figsize=(10, 6))
plt.plot(y_test, label='True Values')
plt.plot(y_pred, label='Predicted Values')
plt.title('True vs Predicted Values')
plt.xlabel('Samples')
plt.ylabel('Adj Close**')
plt.legend()
plt.show()